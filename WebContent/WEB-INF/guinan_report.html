<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="templates/report_style.css">
<script type="text/javascript" src="templates/jquery-2.0.2.min.js"></script>
<script type="text/javascript" src="templates/functions.js"></script>
<title>Guinan :: Search Results</title>

</head>
<body>

	<div class="banner">
		<img src="templates/fin_ovgu_wdok-banner.png">
	</div>
	<h1>Guinan Search Results</h1>
	<div class="assignment_box">
		<div class="assignment_title">
			<h2>
				<a href="#" name="Prolog: Seminarteilnehmer">Prolog:
					Seminarteilnehmer</a>
			</h2>

		</div>
		<div class="assignment">
			<div class="assignment_content">
				<br>
				<br> Die<b> Teilnehmer </b>eines<b> Seminars </b>sollen für ein
				Seminarprojekt<b><b> teams </b></b>bestehend aus zwei<b>
					StudentInnen </b>bilden. Die<b> Seminargruppe </b>besteht aus folgenden
				StudentInnen:<br>
				<br> -<b> Anton </b>(IF)<br>
				<br> -<b> Hagen </b>(CV),<br>
				<br> -<b> Gunther </b>(CV),<br>
				<br> -<b> Adele </b>(IF),<br>
				<br> -<b> Uta </b>(CV) und<br>
				<br> -<b> Anna </b>(IF).<br>
				<br> <br>
				<br> a)<b> Erstellen </b>Sie die Faktenbasis. <b> Schreiben
				</b>Sie ein<b> <u>Prädikat</u>
				</b>teams, welches alle möglichen<b><b> teams </b></b>zurückliefert.
				Welche<b><b> teams </b></b>werden gebildet?<br>
				<br> b)<b> Erweitern </b>Sie Ihre<b> Definition </b>von<b><b>
						teams </b></b>dahingehend, dass die<b><b> teams </b></b>jeweils aus einem<b>
					Student </b>und einer<b><b> Studentin </b></b>bestehen sollen. Welche<b>
					Paare </b>werden jetzt gefunden?<br>
				<br> c) Um eine erfolgreiche<b> Bearbeitung </b>der<b>
					Aufgabe </b>abzusichern, wird zusätzlich gefordert, dass innerhalb des<b><b>
						teams </b></b>jeweils ein(e)<b><b> Studentin </b></b>der<b>
					Fachrichtung </b>'Informatik' und der<b> Fachrichtung </b>'Computervisualistik'
				zusammenarbeiten sollen. Wie sieht jetzt die<b> Definition </b>von<b><b>
						teams </b></b>aus? Welche<b><b> teams </b></b>erhalten Sie jetzt?<br>
				<br>
			</div>
			<p class="assignment_hkeywords">
				<u>human keywords</u><br>
			<div class="human_keys">Prolog&nbsp; Faktenbasis&nbsp;
				Prädikat&nbsp;</div>
			</p>
			<p class="assignment_keywords">
				<b>extracted keywords</b><br>
			<div class="assignment_keys">Teilnehmer&nbsp; Seminars&nbsp;
				Seminarprojekt&nbsp; Teams&nbsp; StudentInnen&nbsp;
				Seminargruppe&nbsp; StudentInnen&nbsp; Anton&nbsp; Hagen&nbsp;
				Gunther&nbsp; Adele&nbsp; Uta&nbsp; Anna&nbsp; Erstellen&nbsp;
				Faktenbasis&nbsp; Schreiben&nbsp; Prädikat&nbsp; Teams&nbsp;
				Teams&nbsp; Erweitern&nbsp; Definition&nbsp; teams&nbsp; Teams&nbsp;
				Student&nbsp; Studentin&nbsp; Paare&nbsp; Bearbeitung&nbsp;
				Aufgabe&nbsp; Teams&nbsp; StudentIn&nbsp; Fachrichtung&nbsp;
				Informatik&nbsp; Fachrichtung&nbsp; Computervisualistik&nbsp;
				Definition&nbsp; teams&nbsp; Teams&nbsp;</div>
			</p>
			<div class="guinan_material_box">
				<div class="guinan_material_title">
					<h3>
						<a href="#">More material ...</a>
					</h3>
				</div>
				<div class="guinan_material">
					<!--  here comes the dynamically fetched material -->
				</div>

			</div>
		</div>
	</div>
	<div class="assignment_box">
		<div class="assignment_title">
			<h2>
				<a href="#" name="Prolog: Einfache Anfragen">Prolog: Einfache
					Anfragen</a>
			</h2>

		</div>
		<div class="assignment">
			<div class="assignment_content">
				<br>
				<br> Stellen Sie eine kleine<b> <u>Wissensbasis</u>
				</b>von<b> Tieren </b>und Jäger-Beute-Paaren nach dem<b> Muster </b>tier(katze)
				und jagt(katze, maus) zusammen. Stellen Sie dann die folgenden
				Anfragen:<br>
				<br> - Welche<b> Tiere </b>jagen Mäuse?<br>
				<br> - Welche<b> Tiere </b>jagen Katzen?<br>
				<br> - Welches<b> Tier </b>ist sowohl<b> Jäger </b>als auch
				Beutetier?<br>
				<br> - Welches<b> Tier </b>ist Beutetier?<br>
				<br> - Welches<b> Tier </b>ist nur Jäger?<br>
				<br> - Wer jagt wen?<br>
				<br> <br>
			</div>
			<p class="assignment_hkeywords">
				<u>human keywords</u><br>
			<div class="human_keys">Prolog&nbsp; Anfragen&nbsp;
				Wissensbasis&nbsp; einfach&nbsp;</div>
			</p>
			<p class="assignment_keywords">
				<b>extracted keywords</b><br>
			<div class="assignment_keys">Wissensbasis&nbsp; Tieren&nbsp;
				Jäger&nbsp; Beute&nbsp; Paaren&nbsp; Muster&nbsp; Anfragen&nbsp;
				Tiere&nbsp; Mäuse&nbsp; Tiere&nbsp; Katzen&nbsp; Tier&nbsp;
				Jäger&nbsp; Beutetier&nbsp; Tier&nbsp; Beutetier&nbsp; Tier&nbsp;
				Jäger&nbsp;</div>
			</p>
			<div class="guinan_material_box">
				<div class="guinan_material_title">
					<h3>
						<a href="#">More material ...</a>
					</h3>
				</div>
				<div class="guinan_material">
					<!--  here comes the dynamically fetched material -->
				</div>

			</div>
		</div>
	</div>
	<div class="assignment_box">
		<div class="assignment_title">
			<h2>
				<a href="#"
					name="strukturelle Induktion: span mit takewhile und dropwhile">strukturelle
					Induktion: span mit takewhile und dropwhile</a>
			</h2>

		</div>
		<div class="assignment">
			<div class="assignment_content">
				<br> <b> Gegeben </b>seien die folgenden<b> Definitionen </b>der
				Haskell-Funktionen takeWhile, <u>dropwhile</u> und span:<br>
				<br> <u>takewhile</u> :: (a -> Bool) -> [a] -> [a]<br> <u>takewhile</u>
				p [] = [] -- tw1<br> <u>takewhile</u> p (x:xs) -- tw2<br>
				| p x = x : <u>takewhile</u> p xs -- tw2.1<br> | otherwise = []
				-- tw2.2<br>
				<br> <u>dropwhile</u> :: (a -> Bool) -> [a] -> [a]<br> <u>dropwhile</u>
				p [] = [] -- dw1<br> <u>dropwhile</u> p xs@(x:xs') -- dw2<br>
				| p x = <u>dropwhile</u> p xs' -- dw2.1<br> | otherwise = xs --
				dw2.2<br>
				<br> <b> <u>span</u>
				</b> :: (a -> Bool) -> [a] -> ([a],[a])<br> <b> <u>span</u>
				</b>p [] = ([],[]) -- span1<br> <b> <u>span</u>
				</b>p xs@(x:xs') -- span2<br> | p x = (x:ys, zs)<br> |
				otherwise = ([],xs)<br> where (ys,zs) =<b> <u>span</u>
				</b>p xs'<br>
				<br> <b> Beweisen </b>Sie durch strukturelle<b> Induktion </b>über
				die Listenlänge, dass für alle endlichen<b> Listen </b>l und für
				beliebige<b> Prädikate </b>p (mit passender Signatur) gilt:<br>
				<br> <b> <u>span</u>
				</b>p l = (takeWhile p l, <u>dropwhile</u> p l)<br>
				<br> Wichtiger Hinweis:<b> Geben </b>Sie bitte bei allen<b>
					Umformungen </b>in<b> Beweisschritten </b>jeweils die verwendeten<b>
					Gleichungen </b>oder sonstigen<b> Begründungen </b>an.<br>
				<br>
			</div>
			<p class="assignment_hkeywords">
				<u>human keywords</u><br>
			<div class="human_keys">Haskell&nbsp; span&nbsp;
				takewhile&nbsp; dropwhile&nbsp; Beweis&nbsp; vollständige
				Induktion&nbsp; Programmeigenschaften&nbsp;</div>
			</p>
			<p class="assignment_keywords">
				<b>extracted keywords</b><br>
			<div class="assignment_keys">Gegeben&nbsp; Definitionen&nbsp;
				Haskell&nbsp; Funktionen&nbsp; Beweisen&nbsp; Induktion&nbsp;
				Listenlänge&nbsp; Listen&nbsp; Prädikate&nbsp; Signatur&nbsp;
				span&nbsp; Hinweis&nbsp; Geben&nbsp; Umformungen&nbsp;
				Beweisschritten&nbsp; Gleichungen&nbsp; Begründungen&nbsp;</div>
			</p>
			<div class="guinan_material_box">
				<div class="guinan_material_title">
					<h3>
						<a href="#">More material ...</a>
					</h3>
				</div>
				<div class="guinan_material">
					<!--  here comes the dynamically fetched material -->
				</div>

			</div>
		</div>
	</div>
	<div class="assignment_box">
		<div class="assignment_title">
			<h2>
				<a href="#" name="Haskell: induction mit foldr">Haskell:
					induction mit foldr</a>
			</h2>

		</div>
		<div class="assignment">
			<div class="assignment_content">
				<br>
				<br> Wie lässt sich <u>induction</u> auf eine<b> Anwendung
				</b>von <u>foldr</u> zurückführen? (s.<b> Vorlesungsfolie </b>14 aus<b>
					FaltungInHaskell </b>)<br> <b> Redefinieren </b>Sie <u>induction</u>
				unter<b> Nutzung </b>von foldr.<br> <b> Testen </b>Sie Ihre<b>
					Definition </b>mit geeigneten<b> Testdaten </b>und reichen Sie diese
				und die<b> Ergebnisse </b>als<b> Kommentar </b>mit ein.<br> <b>
					Können </b>Sie beweisen, dass Ihre<b> Definition </b>mit <u>foldr</u>
				mit der ursprünglichen<b> Definition </b>übereinstimmt?<br>
				<br>
			</div>
			<p class="assignment_hkeywords">
				<u>human keywords</u><br>
			<div class="human_keys">Haskell&nbsp; induction&nbsp;
				foldr&nbsp; Faltung&nbsp; Funktionen höherer Ordnung&nbsp;</div>
			</p>
			<p class="assignment_keywords">
				<b>extracted keywords</b><br>
			<div class="assignment_keys">Anwendung&nbsp;
				Vorlesungsfolie&nbsp; FaltungInHaskell&nbsp; Redefinieren&nbsp;
				Nutzung&nbsp; Testen&nbsp; Definition&nbsp; Testdaten&nbsp;
				Ergebnisse&nbsp; Kommentar&nbsp; Können&nbsp; Definition&nbsp;
				Definition&nbsp;</div>
			</p>
			<div class="guinan_material_box">
				<div class="guinan_material_title">
					<h3>
						<a href="#">More material ...</a>
					</h3>
				</div>
				<div class="guinan_material">
					<!--  here comes the dynamically fetched material -->
				</div>

			</div>
		</div>
	</div>
	<div class="assignment_box">
		<div class="assignment_title">
			<h2>
				<a href="#" name="Prolog: Variablen">Prolog: Variablen</a>
			</h2>

		</div>
		<div class="assignment">
			<div class="assignment_content">
				<br>
				<br> <b> Gegeben </b>sind verschiedene<b> Paare </b>von Listen.<b>
					Können </b>die<b> <u>Variablen</u>
				</b>in den<b> Paaren </b>unifiziert werden? Wenn ja, welchen<b> Wert
				</b>erhalten die Variablen?<br>
				<br> - [X,Y,Z] und [john,likes,fish]<br>
				<br> - [cat] und [X|Y]<br>
				<br> - [X,Y|Z] und [mary,likes,wine]<br>
				<br> - [[the,Y]|Z] und [[X,answer],[is,here]]<br>
				<br> - [X,Y,X] und [a,Z,Z]<br>
				<br> - [[X],[Y],[X]] und [[a],[Z],[Z]]<br>
				<br>
			</div>
			<p class="assignment_hkeywords">
				<u>human keywords</u><br>
			<div class="human_keys">Prolog&nbsp; Variablen&nbsp;
				Unifizieren&nbsp;</div>
			</p>
			<p class="assignment_keywords">
				<b>extracted keywords</b><br>
			<div class="assignment_keys">Gegeben&nbsp; Paare&nbsp;
				Listen&nbsp; Können&nbsp; Variablen&nbsp; Paaren&nbsp; Wert&nbsp;
				Variablen&nbsp;</div>
			</p>
			<div class="guinan_material_box">
				<div class="guinan_material_title">
					<h3>
						<a href="#">More material ...</a>
					</h3>
				</div>
				<div class="guinan_material">
					<!--  here comes the dynamically fetched material -->
				</div>

			</div>
		</div>
	</div>
	<div class="assignment_box">
		<div class="assignment_title">
			<h2>
				<a href="#" name="foldl und foldr">foldl und foldr</a>
			</h2>

		</div>
		<div class="assignment">
			<div class="assignment_content">
				<br>
				<br> In<b> Vorlesung </b>und Übung haben Sie die<b>
					Funktion </b>foldr kennengelernt.<br>
				<br> Eine alternative<b> Faltungsfunktion </b>ist foldl, die
				mit einem<b> Akkumulator </b>und einer<b> Schrittfunktion </b>arbeitet,
				die jeweils einen<b> Akkumulatorwert </b>mit einem<b>
					Listenelement </b>zu einem neuen<b> Akkumulatorwert </b>verknüpft.<br>
				<br> <b> <u>foldl</u>
				</b>ist wie folgt direkt definiert:<br>
				<br> <b> <u>foldl</u>
				</b>:: (a -> b -> a) -> a -> [b] -> a <br>
				<br> <b> <u>foldl</u>
				</b>step zero (x:xs) =<b> <u>foldl</u>
				</b>step (step zero x) xs<br>
				<br> <b> <u>foldl</u>
				</b>_ zero [] = zero<br>
				<br> Eine alternative<b> Definition </b>führt<b> <u>foldl</u>
				</b>auf eine<b> Anwendung </b>von <u>foldr</u> auf folgende<b> Weise
				</b>zurück:<br>
				<br> foldla<b> step </b>zero xs = <u>foldr</u> st id xs zero<br>
				where st x g a = g (step a x)<br>
				<br> Zeigen Sie zunächst durch schrittweise<b> Expansion </b>der
				beiden unterschiedlichen Definitionen, dass für eine beliebige,
				genau zweielementige Liste<br>
				<br> <b> <u>foldl</u>
				</b>step zero xs<br>
				<br> und <br>
				<br> foldla<b> step </b>zero xs <br>
				<br> jeweils denselben<b> Wert </b>ergibt.<br> <b>
					Beweisen </b>Sie dann durch strukturelle<b> Induktion </b>über xs, dass
				die beiden<b> Funktionen </b>foldl und foldla extensional gleich
				sind (d.h. dass sie für beliebige zweistellige<b> Funktionen </b>step
				:: a -> b -> a, beliebige<b> Startwerte </b>zero :: a und alle
				endlichen<b> Listen </b>xs :: [b] stets zu denselben<b> Werten </b>führen).<br>
				<br>
			</div>
			<p class="assignment_hkeywords">
				<u>human keywords</u><br>
			<div class="human_keys">Haskell&nbsp; Faltung&nbsp; foldr&nbsp;
				foldl&nbsp; Funktion höherer Ordnung&nbsp;</div>
			</p>
			<p class="assignment_keywords">
				<b>extracted keywords</b><br>
			<div class="assignment_keys">Vorlesung&nbsp; bung&nbsp;
				Funktion&nbsp; Faltungsfunktion&nbsp; Akkumulator&nbsp;
				Schrittfunktion&nbsp; Akkumulatorwert&nbsp; Listenelement&nbsp;
				Akkumulatorwert&nbsp; foldl&nbsp; foldl&nbsp; step&nbsp;
				Definition&nbsp; Anwendung&nbsp; Weise&nbsp; Expansion&nbsp;
				Definitionen&nbsp; Liste&nbsp; Wert&nbsp; Beweisen&nbsp;
				Induktion&nbsp; Funktionen&nbsp; Funktionen&nbsp; step&nbsp;
				Startwerte&nbsp; Listen&nbsp; Werten&nbsp;</div>
			</p>
			<div class="guinan_material_box">
				<div class="guinan_material_title">
					<h3>
						<a href="#">More material ...</a>
					</h3>
				</div>
				<div class="guinan_material">
					<!--  here comes the dynamically fetched material -->
				</div>

			</div>
		</div>
	</div>
</body>
</html>